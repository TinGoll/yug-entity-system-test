import Engine from "yug-entity-system";

/**
 * Очень серозная документация.
 * Часть первая создание компонента для сущностей.
***********************************************
  План.
1.	Создадим движок. 
2.	Отслеживаем ошибки.
3.	Создаем креатор и с помощью его - независимый объект компонента.
4.	Редактируем и добавляем свойства.
5.	Сохраняем его как шаблон.
6.	Проверяем результат
*/

/** Создаем instance класса двигателя. Тут ничего не изменилось
 * Создавать таким образом движок, можно в любом месте приложения, он все равно будет хранить 
 * все изменения и данные.
*/


// 1. Создание
const engine = new Engine();

// 2. Ошибки
/**
 * Я отказался от генерации ошибок, так как не везде удобно их отлавливать.
 * Теперь если что-то "не сохранилось" или "не присвоилось", надо смотреть в событиях.
 * Регистрируем два варианта событий
 */
Engine.on('error', ({message}) => {
  /** Тут генерируются ошибки, связанные с работой самого движка
   * То есть некорректно присвоенный тип поля для компонента тут не увидишь.
   * Приходит только уведомление, удобно для вывода пользователю
   */
  console.log('---------------Проверяем как работают общие ошибки---------------');
  console.log(message); // Делаем с этим , что считаем нужным
  console.log('-----------------------------------------------------------------');
  
});

Engine.on('on-component-error', ({component, componentName, propertyName, err}) => {
  /**
   * Более конкретное событие для детальной работы над ошибками.
   * Содержит сам инстанс компонента, его название и (необязательно) название свойства, в котором случилась ошибка.
   * Ну и сам объект ошибки, такой же как с сервера. Имеет err.message и массив err.errors. Автокомплит, должен подсказать
   */
  console.log('---------------Ошибка случилась в копоненте:---------------');
  console.log(componentName);
  console.log('message', err.message);
  console.log('errors', err.errors);
  
})

//3. Создаем копонент

const creator = engine.nomenclatureCreator(); // Как и в прошлой версии, надо создать креатор.


 //Тепер с помощью метода крейт, в который мы передаем один из двух вариантов 'nomenclature' или 'component'

/**
 * При создании нового компоннета, необходимо ввести его имя. К примеру  - geometry
 * 
 *  Кстати, давай провери как работаю общие ошибки. Введем что - то несуществующее и заткнем рот компилятору
 */
creator.create('Всякая аххинея' as any, 'И тут какую то ерунду' as any);

/**
 * Смотрим в логи
 */


const component = creator.create('component', 'geometry'); // автокомплит должен подсказать, какие аргументы можно ввести

/**
 * Теперь мы имеем независимый от сущьностти компонент у себя на руках
 * можно не сохранять его в отдельную переменную, а работать сразу с креатора:
 * creator.currentComponent - только что созданный нами компонент.
 */

/** Комопнент сейчас пустой и смое время увидеть как работают ошибки компонентах
 * Давай попробуем сохранить его таким какой  он есть
 */

component.SaveAsTemplate(); // Ничего не вышло, смотрим логи.


/**
 * Давай по человечески создадим свойство
 */

/** Передать нужно два обязательных аргумента (можно заполнить сразу все, авткомплит подскажет)
 * Рузальтатом работы этой функции, будет интерактивный объект. Работая с которым, мы избегаем мутации.
 */
const property =  component.crateProperty({
  propertyName: 'height',
  propertyType: 'number'
})

/** Запоняем дальше... */
property.propertyDescription = 'Высота' // Присваиваем русское название;
property.propertyFormula = '2+2'


property.bindingToList = true // Указываем, что значение этого свойства нужно выбрать из списка, отправив запрос на сервер 

property.addAttributes('readonly').addAttributes('required') // Задаем атрибуты для этого свойства делаем его обязательным и только для тчения)

property.removeAttributes('readonly') // Удаляем только для чтения

property.addAttributes('required') // Забываем, что устанавливали уже этот атрибут, но ошибки нет и он не задвоится

/**
 * Когда наигрались, сохраняем новое весь компонент.
 * 
 */
console.log('-------------------Теперь все сохранилось-------------------')

component.SaveAsTemplate(); // или creator.saveComponent()

console.log(creator.componentNames()); // убеждаемся что он сохранился

component.build() // Сборка для отправки на сервер или добавления в сущьность

component.setComponent(component.build()) // Восстанавливаем состояние, если нам надо и снова работаем

/** Первая часть все.
 * Продолжение следует
 */







